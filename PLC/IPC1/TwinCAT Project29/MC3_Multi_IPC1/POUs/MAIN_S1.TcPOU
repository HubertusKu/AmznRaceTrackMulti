<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="MAIN_S1" Id="{1e7add0e-820a-414b-96de-5fe81886ac49}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN_S1

VAR
	b110SyncState AT %I* :UINT ;
	b110State AT %I* :UINT;  
	EtherCATWCState23To49 AT %I* : BOOL; 
	EtherCATWCState50To76 AT %I* : BOOL; 
	AktiveSystem : BOOL := TRUE;
	bSwitch : BOOL := TRUE;
	nState: UINT;
	MoverState :ARRAY[1..GVL_MC.nNumMovers] OF UINT;
	nForCounter ,i: UINT;
	Velo : LREAL := 2000;
	//mover :ARRAY[1..nNumMovers] OF MC_PlanarMover;
	
	LocalSystemTime : FB_LocalSystemTime;
	
	fbTrackobject : FB_TrackObject;

	ipXlMover: 	I_XtsXlMover1;


	state : INT := -1;
	arrivedOTCID : OTCID;
	Start :BOOL;
	bAlldone : BOOL;
	
	

	test : otcid; 
	XPU_Number : UINT := 1; 	
	
	Short : BOOL := TRUE;
	
	XtsOutterLoopOid: OTCID ;	
	XtsShortcutOid: OTCID ;
	Switch : FB_PWM;
	Init : BOOL ; 
	EndTrack : INT := E_TrackNum.MainEnd;
 	StartTrack : INT :=E_TrackNum.MainStart ;
	MoverNo : DINT;
	SystemReady: BOOL;
	IsDetectionOnStartupEnabled : BOOL := FALSE;
	
	MagnetValue AT%Q*: INT;
	bMagnetOn : BOOL;	
	Fault : BOOL;
	SwitchCurrent :lreal := 7;
	Switchcounter : DINT;
	FP_Counter : r_trig;
	
	searchGap : F_SearchTheBigTrackForAHole; 
	aMoverTrack : ARRAY[1..GVL_Mc.nNumMovers] OF otcid;
	FirstMoverTrackPos : LREAL;
	MoverGap : LREAL;
	FTrigTrackCount : F_Trig;
	MoverNo1  : UDINT;
	gapStart: LREAL := 5600;
	gapLength: LREAL := 2000;
	moverInFront: UDINT;
	mover1FollowDist: LREAL;
	followSyncPos: LREAL;
	masterSyncPos: LREAL;
	masterPosAtSync: LREAL;
	followerPosAtSync: LREAL;
	endOfBigTrack : LREAL; 
     endOfSmallTrack : LREAL; 
     endOfMainTrack : LREAL; 
     followerToEndOfTrack: LREAL;
     leaderToEndofTrack: LREAL;
     distToMoverInFront: LREAL;
     vara: Tc3_Mc3PlanarMotion.PlanarObjectInfo;
  
     getList: BOOL;
     directMerge: BOOL;
     mergeNotPossible: BOOL;

	A : LREAL := 0.63;
	B : LREAL := 0.21;
	C : LREAL := 6;
	
	cmdFeedback: Tc3_XtsInterface.XtsCommandFeedback;
	BUFFER: BYTE;
	
	xReset AT %Q*: BOOL;
	xStart AT %Q*: BOOL;
	EtherCATFault: BOOL;
	syncFault: BOOL;

	
	haltDynamics : DynamicConstraint_PathXY;
	stMoverConfigSlow	: ST_MoverConfig;
	stMoverConfigNormal : ST_MoverConfig;
	stMoverConfigFast  : ST_MoverConfig;
	stMoverCfgAggressive : ST_MoverConfig;
	stMoverCfgHalt : ST_MoverConfig;
	MoverStopDone : BOOL;
	
	Fp_error : R_trig;
	
END_VAR


VAR_INPUT
	remoteState AT %I*: INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// =====================
// Initalize XTS Utility
GVL_MC.fbXtsEnvironment.Init(GVL_MC.cmdFeedback);
IF NOT GVL_MC.cmdFeedback.IsDone THEN
	RETURN;
END_IF
IF EtherCATWCState23To49 OR EtherCATWCState50To76 THEN 
	EtherCATFault := TRUE; 
END_IF
IF b110SyncState <> 1 THEN 
	syncFault := TRUE;  
END_IF

// =====================
GVL_MC.ipXtsProcessingUnit :=  GVL_MC.fbXtsEnvironment.ProcessingUnit(XPU_Number,0);
FOR i := 1 TO GVL_MC.nNumMovers DO 
	IF NOT Init THEN
		ipXlMover  :=  GVL_MC.fbXtsEnvironment.ProcessingUnit(XPU_Number, 0).XlMover(i, 0);
		GVL_MC.fbMover[i].Init(ipXlMover, GVL_MC.ipXtsProcessingUnit); 
		gvl_mc.iMover[i] := gvl_mc.fbmover[i];
	END_IF
	
//	Fp_error(clk := GVL_MC.fbMover[i].P_PlanarMover.Error AND GVL_MC.fbMover[i].XtsXlMover.GetIsActive(0) AND state = 100);
//	IF Fp_error.Q THEN
//		state := 140;
//		Fault := TRUE;
//		bMagnetOn := FALSE;
//		ADSLOGSTR(msgCtrlMask:= ADSLOG_MSGTYPE_LOG , msgFmtStr:= 'Mover %s Faulted ' , strArg:= INT_TO_STRING(i));
//	ELSE
//		Fault := FALSE;
//	END_IF
	
	GVL_MC.Feedback[i].Update();
	GVL_MC.fbMover[i].CycleUpdate();
	//GVL_MC.fbMover[i].P_Dynamics.SetValuesVADJ(Velo + (i - 1) * 50, gvl_mc.standardAccel, gvl_mc.standardDecel, gvl_mc.standardJerk);
	GVL_MC.fbMover[i].P_Dynamics.SetValuesVADJ(Velo, 4000, 10000, 16000);

	IF GVL_MC.fbMover[i].P_PlanarMover.Error  AND GVL_MC.iMover[i].XtsXlMover.GetIsActive(0) THEN
		Fault := TRUE;
	END_IF
END_FOR	

fbTrackobject(TrackID:= GVL_mc.aMcTracks[E_TrackNum.big].MCTOPLC_STD.TrackOID,iMover:= gvl_mc.iMover ); 
fbTrackobject.CyclicUpdate();

FOR i := 1 TO GVL_MC.nNumTracks DO 
	GVL_MC.aMcTracks[i].Update();
	GVL_MC.TrackFeedback[i].Update();
END_FOR	

IF NOT Init THEN
	Init := TRUE;
END_IF


Switch(SafeetyOK :=TRUE ,);

GVL_DataExchange.Dynamics.v := Velo;

IF state < 99 AND xReset THEN 
	IF State = 1 THEN 
		xReset := FALSE; 
	END_IF 
	state := 0; 
END_IF
IF state = 99 AND xStart AND remoteState  = 99 THEN   
	state := 100;  
END_IF

CASE state OF
	0: 
		
		FOR i := 1 TO GVL_MC.nNumTracks DO  
			GVL_MC.aMcTracks[i].Enable(GVL_MC.TrackFeedback[i]);
			state := 1;
		END_FOR
		
	1: 	
		bAlldone := TRUE;
		FOR i := 1 TO GVL_MC.nNumTracks DO  
			bAlldone := bAlldone AND GVL_MC.aMcTracks[i].MCTOPLC_STD.State = MC_PLANAR_STATE.Enabled ;
		END_FOR

 		IF bAlldone THEN
			state := 2;
		END_IF

	2:	
		IF AktiveSystem THEN
			FOR i := GVL_MC.nNumActiveMovers + 1 TO GVL_MC.nNumMovers DO  
				GVL_MC.fbMover[i].XlProcessingUnit.XlMover(i,0).SetStartupTrackPosition(0.2,0);	
				GVL_MC.fbMover[i].XlProcessingUnit.XlMover(i,0).SetIsVirtualFeedbackEnabled(1,0);
			END_FOR 
		ELSE
			FOR i := 1 TO GVL_MC.nNumMovers DO  
				GVL_MC.fbMover[i].XlProcessingUnit.XlMover(i,0).SetStartupTrackPosition(0.2,0);	
				GVL_MC.fbMover[i].XlProcessingUnit.XlMover(i,0).SetIsVirtualFeedbackEnabled(1,0);
			END_FOR 
		END_IF			
		state := 5;
	5: 
		FOR i := 1 TO GVL_MC.nNumMovers DO
			GVL_MC.fbMover[i].XlProcessingUnit.XlMover(i,0).TriggerArrive(0);	
			
		END_FOR
		
		IF AktiveSystem THEN
			state := 10;
		ELSE
			state := 100;
		END_IF	

	10:
		FOR i := 1 TO GVL_MC.nNumActiveMovers DO
			GVL_MC.fbMover[i].P_PlanarMover.Reset(0);	
		//	GVL_MC.fbMover[i].P_PlanarMover.Enable(0);		
		END_FOR
		state := 11; 
	11:
		FOR i := 1 TO GVL_MC.nNumActiveMovers DO
		//	GVL_MC.fbMover[i].P_PlanarMover.Reset(0);	
			GVL_MC.fbMover[i].P_PlanarMover.Enable(0);		
		END_FOR
		state := 15;	
	15:
		bAlldone := TRUE;
		FOR i := 1 TO GVL_MC.nNumActiveMovers DO  
			bAlldone := bAlldone AND GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.STD.State = MC_PLANAR_STATE.Enabled ;	
		END_FOR
		
		IF bAlldone THEN
			state := 18;
		END_IF
	18: 
	
		FOR i := 1 TO GVL_MC.nNumActiveMovers DO  
			GVL_MC.fbMover[i].JoinNearestTrack();	
		END_FOR
		state := 20;
	
	20:
		bAlldone := TRUE;
		FOR i := 1 TO GVL_MC.nNumActiveMovers DO  
			bAlldone := bAlldone AND GVL_MC.fbMover[i].fbPlanarMover.MCTOPLC.STD.CommandMode = MC_PLANAR_MOVER_COMMAND_MODE.OnTrack  ;	
			MoverState[i] := 10;
			
		END_FOR

		IF bAlldone THEN
			state := 99;
			Fault := FALSE;
		END_IF
		
	99:
	 	IF GVL_MC.nNumActiveMovers = 0 THEN
			state := 100;
		END_IF
		
	100: 
		arrivedOTCID := GVL_MC.EnterSystem.PopFirstMoverInQueue();
		IF arrivedOTCID <> 0 THEN
			FOR i := 1  TO GVL_MC.nNumMovers DO
				IF GVL_MC.fbMover[i].P_MoverOTCID = arrivedOTCID THEN
					MoverState[i] := 0;
				END_IF
			END_FOR
		END_IF
	
		FOR i := 1 TO GVL_MC.nNumMovers DO 
			
			IF MoverNo1 <> 0 AND_THEN GVL_MC.fbMover[MoverNo1].P_PlanarMover.MCTOPLC.SETONTRACK.TrackOID =  GVL_MC.aMcTracks[E_TrackNum.Big].MCTOPLC_STD.TrackOID THEN
				Short := FALSE;
			END_IF	
		
			CASE MoverState[i] OF 
			0:		 
				IF  bSwitch AND GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.TrackOID = GVL_MC.aMcTracks[E_TrackNum.MainStart].MCTOPLC_STD.TrackOID    THEN
					IF NOT short   THEN
						GVL_MC.fbMover[i].MoveOnTrack(GVL_MC.aMcTracks[E_TrackNum.Small], GVL_MC.aMcTracks[E_TrackNum.Small].GetLength()/2, GVL_MC.defaultGap);
						MoverNo1 := i;
						Short := TRUE;
						MoverState[i] := 6;
					ELSE
						GVL_MC.fbMover[i].MoveOnTrack(GVL_MC.aMcTracks[E_TrackNum.Big],(GVL_MC.aMcTracks[E_TrackNum.Big].GetLength()/2), GVL_MC.defaultGap);			
						MoverState[i] := 10;
					END_IF
				ELSIF NOT bSwitch AND  GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.TrackOID = GVL_MC.aMcTracks[E_TrackNum.MainStart].MCTOPLC_STD.TrackOID THEN
					GVL_MC.fbMover[i].MoveOnTrack(GVL_MC.aMcTracks[EndTrack],GVL_MC.aMcTracks[EndTrack].GetLength()-450, GVL_MC.defaultGap);
					MoverState[i] := 12;				
				END_IF
			
		
				
			6:
               
                fbTrackobject.findMergePosition(
                   mergeSyncCommandPos := gapStart , 
                   spaceToMerge := gapLength, 
                   nMoverToFollow => moverInFront, 
                   mergeWithoutFollow => directMerge, 
                   mergeNotPossible => mergeNotPossible); 
								
                IF (directMerge OR moverInFront <> 0) AND NOT mergeNotPossible THEN
                                MoverState[i] := 7;
                END_IF 
			7:  //merge with gap zero
					//issue commmand to sync 
					IF  directMerge THEN 
						GVL_MC.fbMover[i].P_Dynamics.SetValuesVADJ(stMoverConfigNormal.velo,stMoverConfigNormal.Accel,stMoverConfigNormal.Decel,stMoverConfigNormal.Jerk);
						fbMover[i].MoveOnTrack(track:= GVL_Mc.aMCTracks[E_TrackNum.MainEnd], targetPos:= GVL_Mc.aMCtracks[E_TrackNum.Mainend].GetLength()-500, gap:= GVL_MC.defaultGap);

						MoverState[i] := 10; 
					ELSIF moverInFront <>0 THEN 
						fbMover[i].P_Dynamics.SetValuesVADJ(stMoverConfigNormal.velo,stMoverConfigNormal.Accel,stMoverConfigNormal.Decel,stMoverConfigNormal.Jerk);
						masterSyncPos := GVL_Mc.aMCTracks[E_TrackNum.Big].GetLength()-2500;
						masterPosAtSync := Mover[moverInFront].MoverPos; 
						followSyncPos := GVL_Mc.aMCTracks[E_TrackNum.Small].GetLength()- GVL_MC.defaultGap -2500;
						followerPosAtSync :=Mover[nForCounter].MoverPos; 
						fbMover[i].SyncToOtherMover( 
							masterSyncPos := masterSyncPos,
							masterTrack := GVL_Mc.aMCTracks[E_TrackNum.Big],
							followerSyncPos := followSyncPos,
							followerTrack := GVL_Mc.aMCTracks[e_TrackNum.Small],
							PlanarMoverToFollow := fbMover[moverInFront].P_PlanarMover,
							velo:= stMoverConfigNormal.velo);
							MoverState[i] := 8; 
						// reduce the gap of the leading mover 
						fbMover[moverInFront].MoveOnTrack(track:= GVL_Mc.aMcTracks[E_TrackNum.Big], targetPos:= GVL_Mc.aMcTracks[E_TrackNum.Big].GetLength()-500, gap:= 0);

					END_IF 
					
				
					
			//	8: // wait for in Sync 
			//		IF fbMover[nForCounter].P_SyncFeedback.Active AND MOver[moverInFront].TrackID =  GVL_Mc.aMcTracks[E_TrackNum.Big].MCTOPLC_STD.TrackOID THEN // actively syncing calculate distance from mover 
			//			followerToEndOfTrack := fbMover[nForCounter].distToEndOfTrack; 
			//			leaderToEndofTrack := fbMover[moverInFront].distToEndOfTrack; 
			//			distToMoverInFront := followerToEndOfTrack - leaderToEndofTrack; 
			//		ELSE 
			//			followerToEndOfTrack := 0; 
			//			leaderToEndofTrack := 0; 
			//			distToMoverInFront := 0;
			//		END_IF
			//		
			//		IF fbMover[nForCounter].P_SyncFeedback.inSync OR  MOver[nForCounter].TrackID =  GVL_Mc.aMcTracks[E_TrackNum.Mainend].MCTOPLC_STD.TrackOID THEN 
			//			MoverState[nForCounter] := 10;
			//			//IsMoverCommandedInShortcut :=FALSE;
			//		ELSIF	fbMover[nForCounter].P_SyncFeedback.Error THEN
			//			MoverState[nForCounter] := 60;
			//		END_IF 


			
  			
                  
  			8: // wait for in Sync 
                  IF Gvl_mc.fbMover[i].P_SyncFeedback.Active AND  gvl_mc.MOver[moverInFront].TrackID =  GVL_Mc.aMCTracks[E_TrackNum.Big].MCTOPLC_STD.TrackOID THEN // actively syncing calculate distance from mover 
                  		
						followerToEndOfTrack := endOfSmallTrack - gvl_mc.Mover[i].MoverPos; 
                  		leaderToEndofTrack := endOfBigTrack - gvl_mc.Mover[moverInFront].MoverPos; 
                  		distToMoverInFront := followerToEndOfTrack - leaderToEndofTrack; 
						
                  ELSE 
					//	gvl_mc.fbMover[moverInFront].P_MoveOnTrackOptions.gap := 1000;
                 		followerToEndOfTrack := 0; 
                 		leaderToEndofTrack := 0; 
                 		distToMoverInFront := 0;
                  END_IF
                  IF gvl_mc.fbMover[i].P_SyncFeedback.inSync  AND  Gvl_mc.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.SetPos > 5500 THEN // OR gvl_mc.MOver[i].TrackID =  GVL_Mc.aMCTracks[E_TrackNum.MainEnd].MCTOPLC_STD.TrackOID THEN 
                        gvl_mc.fbMover[moverInFront].P_MoveOnTrackOptions.gap := GVL_MC.defaultGap;  //  set mover in fronts gap
						gvl_MC.fbMover[I].P_MoveOnTrackOptions.gap := GVL_MC.defaultGap; //
						gvl_mc.fbMover[i].MoveOnTrack(GVL_Mc.aMcTracks[E_TrackNum.MainEnd], GVL_Mc.aMCTracks[E_TrackNum.MainEnd].GetLength()-200, GVL_MC.defaultGap);
						MoverState[i] := 10;
                  END_IF

			10:
				 //gvl_mc.fbMover[i].P_MoveOnTrackOptions.gap := ;
				 // If the mover is 500mm onto the end track re-issue a move command 
				IF SystemReady AND (  GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.SetPos > 500 AND GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.TrackOID <>  GVL_MC.aMcTracks[StartTrack].MCTOPLC_STD.TrackOID) THEN
					GVL_MC.fbMover[i].MoveOnTrack(GVL_MC.aMcTracks[EndTrack], GVL_MC.aMcTracks[EndTrack].GetLength()- 200, GVL_MC.defaultGap);
					MoverState[i] := 12;
				END_IF
		
			12: 
				//500mm after that the boundary change commmand is issued 
				IF GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.SetPos > GVL_MC.aMcTracks[E_TrackNum.MainEnd].GetLength() - 2300 AND // 2300
				(GVL_MC.fbMover[i].P_PlanarMover.MCTOPLC.SETONTRACK.TrackOID = GVL_MC.aMcTracks[E_TrackNum.MainEnd].MCTOPLC_STD.TrackOID)  THEN 
					GVL_MC.fbMover[i].LeaveSystemAt(GVL_MC.ExitSystem); 
					MoverState[i] := 15; 
				END_IF
				
			15:
			 	IF GVL_MC.fbMover[i].XlProcessingUnit.XlMover(i,0).GetIsVirtualFeedbackEnabled(0) AND //In some cases the planar mover gots an error, we have to evaluate why
					GVL_MC.fbMover[i].P_PlanarMover.Error THEN
					GVL_MC.fbMover[i].P_PlanarMover.Reset(0);
					MoverState[i] := 16; 
				END_IF
				
			16: 
				GVL_MC.fbMover[i].P_PlanarMover.Disable(0);
				MoverState[i] := 17; 
		
			END_CASE
		END_FOR	
		
		140:
			FOR i := 1 TO GVL_MC.nNumMovers DO  
				GVL_MC.fbMover[i].P_PlanarMover.Halt(GVL_MC.Feedback[i], haltDynamics);
			END_FOR	
			
				state := 145;
			
		145:
			bAllDone := TRUE;
				FOR i := 1 TO GVL_MC.nNumMovers DO  
				IF NOT(GVL_MC.Feedback[i].Done OR GVL_MC.Feedback[i].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				state := 150;
			END_IF
		
		//Disable
		150:
			MoverStopDone := TRUE;
			FOR i := 1 TO GVL_MC.nNumMovers DO  
					GVL_MC.fbMover[i].P_PlanarMover.Disable(GVL_MC.Feedback[i]);
			END_FOR
				
			state := 0;
		
		
	
END_CASE

//bMagnetOn := FALSE;
FOR nForCounter:=1 TO GVL_MC.nNumMovers DO
	
//	IF  GVL_MC.fbMover[nForCounter].XtsXlMover.GetPositionInfo_trackObjectId(0) = GVL_mc.XtsShortcutOid AND (IsBetween(GVL_MC.fbMover[nForCounter].XtsXlMover.GetPositionInfo_trackPosition(0), gvl_mc.fMagnetEntry - (Velo*0.06), gvl_mc.fMagnetExit(*- Velo*0.04*))) THEN
//		bMagnetOn := TRUE;
//	END_IF
END_FOR


		SwitchCurrent := ((A*(((Velo/1000)*(Velo/1000))))+(B*(Velo/1000))+C);
IF bMagnetOn AND NOT Fault THEN

	MagnetValue := TO_INT(SwitchCurrent*1310);
ELSE
 	MagnetValue := 0;
END_IF

FP_Counter(clk:=bMagnetOn);

IF FP_Counter.Q THEN
	Switchcounter := Switchcounter+1;

END_IF

//distanceMonitoring of Mover 1 when on the big track 
IF GVL_MC.Mover[1].TrackID = GVL_Mc.aMcTracks[E_TrackNum.MainStart].MCTOPLC_STD.TrackOID THEN //calculate out how far it is to the mover in front 
	IF GVL_MC.Mover[moverInFront].MoverPos -  GVL_Mc.Mover[1].MoverPos > 10 THEN 
		mover1FollowDist := GVL_Mc.Mover[moverInFront].MoverPos -  GVL_Mc.Mover[1].MoverPos;
	END_IF   
END_IF

]]></ST>
    </Implementation>
    <LineIds Name="MAIN_S1">
      <LineId Id="5027" Count="5" />
      <LineId Id="5679" Count="0" />
      <LineId Id="5682" Count="4" />
      <LineId Id="5033" Count="3" />
      <LineId Id="5038" Count="0" />
      <LineId Id="5755" Count="0" />
      <LineId Id="5039" Count="0" />
      <LineId Id="5754" Count="0" />
      <LineId Id="5040" Count="0" />
      <LineId Id="5797" Count="0" />
      <LineId Id="5799" Count="7" />
      <LineId Id="5907" Count="0" />
      <LineId Id="5904" Count="0" />
      <LineId Id="5041" Count="1" />
      <LineId Id="5578" Count="1" />
      <LineId Id="5741" Count="0" />
      <LineId Id="5562" Count="0" />
      <LineId Id="5561" Count="0" />
      <LineId Id="5563" Count="0" />
      <LineId Id="5043" Count="0" />
      <LineId Id="5749" Count="0" />
      <LineId Id="5751" Count="0" />
      <LineId Id="5750" Count="0" />
      <LineId Id="5748" Count="0" />
      <LineId Id="5044" Count="3" />
      <LineId Id="5694" Count="2" />
      <LineId Id="5048" Count="3" />
      <LineId Id="5527" Count="0" />
      <LineId Id="5525" Count="0" />
      <LineId Id="5666" Count="0" />
      <LineId Id="5665" Count="0" />
      <LineId Id="5677" Count="1" />
      <LineId Id="5676" Count="0" />
      <LineId Id="5667" Count="1" />
      <LineId Id="5670" Count="2" />
      <LineId Id="5053" Count="1" />
      <LineId Id="5376" Count="20" />
      <LineId Id="5507" Count="0" />
      <LineId Id="5397" Count="3" />
      <LineId Id="5508" Count="0" />
      <LineId Id="5401" Count="1" />
      <LineId Id="5405" Count="3" />
      <LineId Id="5529" Count="0" />
      <LineId Id="5409" Count="9" />
      <LineId Id="5912" Count="0" />
      <LineId Id="5419" Count="2" />
      <LineId Id="5914" Count="4" />
      <LineId Id="5913" Count="0" />
      <LineId Id="5422" Count="20" />
      <LineId Id="5565" Count="0" />
      <LineId Id="5443" Count="3" />
      <LineId Id="5566" Count="0" />
      <LineId Id="5447" Count="0" />
      <LineId Id="5736" Count="4" />
      <LineId Id="5121" Count="1" />
      <LineId Id="5723" Count="0" />
      <LineId Id="5729" Count="0" />
      <LineId Id="5732" Count="3" />
      <LineId Id="5730" Count="1" />
      <LineId Id="5725" Count="0" />
      <LineId Id="5123" Count="0" />
      <LineId Id="5518" Count="0" />
      <LineId Id="5521" Count="1" />
      <LineId Id="5516" Count="1" />
      <LineId Id="5707" Count="0" />
      <LineId Id="5124" Count="0" />
      <LineId Id="5463" Count="14" />
      <LineId Id="5822" Count="0" />
      <LineId Id="5864" Count="0" />
      <LineId Id="5866" Count="7" />
      <LineId Id="5902" Count="0" />
      <LineId Id="5874" Count="1" />
      <LineId Id="5865" Count="0" />
      <LineId Id="5823" Count="24" />
      <LineId Id="5876" Count="1" />
      <LineId Id="5848" Count="10" />
      <LineId Id="5911" Count="0" />
      <LineId Id="5859" Count="4" />
      <LineId Id="5808" Count="2" />
      <LineId Id="5610" Count="0" />
      <LineId Id="5653" Count="0" />
      <LineId Id="5633" Count="3" />
      <LineId Id="5659" Count="0" />
      <LineId Id="5637" Count="1" />
      <LineId Id="5662" Count="0" />
      <LineId Id="5639" Count="0" />
      <LineId Id="5660" Count="0" />
      <LineId Id="5640" Count="5" />
      <LineId Id="5692" Count="1" />
      <LineId Id="5663" Count="0" />
      <LineId Id="5646" Count="0" />
      <LineId Id="5583" Count="0" />
      <LineId Id="5478" Count="0" />
      <LineId Id="5910" Count="0" />
      <LineId Id="5909" Count="0" />
      <LineId Id="5479" Count="3" />
      <LineId Id="5575" Count="0" />
      <LineId Id="5484" Count="0" />
      <LineId Id="5691" Count="0" />
      <LineId Id="5567" Count="0" />
      <LineId Id="5485" Count="3" />
      <LineId Id="5919" Count="0" />
      <LineId Id="5921" Count="8" />
      <LineId Id="5920" Count="0" />
      <LineId Id="5701" Count="0" />
      <LineId Id="5183" Count="0" />
      <LineId Id="5795" Count="1" />
      <LineId Id="5768" Count="26" />
      <LineId Id="5184" Count="4" />
      <LineId Id="5559" Count="0" />
      <LineId Id="5531" Count="10" />
      <LineId Id="5564" Count="0" />
      <LineId Id="5542" Count="16" />
      <LineId Id="5189" Count="1" />
      <LineId Id="1513" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>